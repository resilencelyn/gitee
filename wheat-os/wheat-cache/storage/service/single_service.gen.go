// Code generated by gen-struct. DO NOT EDIT.
// make gen-service generated
package service

import (
	context "context"

	"gitee.com/wheat-os/wheatCache/pkg/event2"
	"gitee.com/wheat-os/wheatCache/pkg/lru"
	"gitee.com/wheat-os/wheatCache/pkg/proto"
)

func (s *singleService) LIndex(
	ctx context.Context,
	req *proto.LIndexRequest,
) (*proto.LIndexResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LIndex(req.Key, req.Index)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LIndex", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LIndexResponse), nil
}

func (s *singleService) LLen(
	ctx context.Context,
	req *proto.LLenRequest,
) (*proto.LLenResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LLen(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LLen", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LLenResponse), nil
}

func (s *singleService) LPop(
	ctx context.Context,
	req *proto.LPopRequest,
) (*proto.LPopResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LPop(req.Key, req.Count)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LPop", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LPopResponse), nil
}

func (s *singleService) LPush(
	ctx context.Context,
	req *proto.LPushRequest,
) (*proto.LPushResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LPush(req.Key, req.Values)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LPush", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LPushResponse), nil
}

func (s *singleService) LPushX(
	ctx context.Context,
	req *proto.LPushXRequest,
) (*proto.LPushXResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LPushX(req.Key, req.Values)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LPushX", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LPushXResponse), nil
}

func (s *singleService) LRange(
	ctx context.Context,
	req *proto.LRangeRequest,
) (*proto.LRangeResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LRange(req.Key, req.Start, req.End)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LRange", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LRangeResponse), nil
}

func (s *singleService) LRem(
	ctx context.Context,
	req *proto.LRemRequest,
) (*proto.LRemResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LRem(req.Key, req.Count, req.Value)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LRem", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LRemResponse), nil
}

func (s *singleService) LSet(
	ctx context.Context,
	req *proto.LSetRequest,
) (*proto.LSetResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LSet(req.Key, req.Index, req.Value)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LSet", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LSetResponse), nil
}

func (s *singleService) RPop(
	ctx context.Context,
	req *proto.RPopRequest,
) (*proto.RPopResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.RPop(req.Key, req.Count)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("RPop", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.RPopResponse), nil
}

func (s *singleService) LTrim(
	ctx context.Context,
	req *proto.LTrimRequest,
) (*proto.LTrimResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.LTrim(req.Key, req.Start, req.End)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("LTrim", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.LTrimResponse), nil
}

func (s *singleService) RPush(
	ctx context.Context,
	req *proto.RPushRequest,
) (*proto.RPushResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.RPush(req.Key, req.Values)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("RPush", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.RPushResponse), nil
}

func (s *singleService) RPushX(
	ctx context.Context,
	req *proto.RPushXRequest,
) (*proto.RPushXResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.RPushX(req.Key, req.Values)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("RPushX", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.RPushXResponse), nil
}

func (s *singleService) HDel(
	ctx context.Context,
	req *proto.HDelRequest,
) (*proto.HDelResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HDel(req.Key, req.HKeys)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HDel", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HDelResponse), nil
}

func (s *singleService) HExists(
	ctx context.Context,
	req *proto.HExistsRequest,
) (*proto.HExistsResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HExists(req.Key, req.HKey)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HExists", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HExistsResponse), nil
}

func (s *singleService) HGet(
	ctx context.Context,
	req *proto.HGetRequest,
) (*proto.HGetResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HGet(req.Key, req.HKeys)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HGet", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HGetResponse), nil
}

func (s *singleService) HGetAll(
	ctx context.Context,
	req *proto.HGetAllRequest,
) (*proto.HGetAllResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HGetAll(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HGetAll", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HGetAllResponse), nil
}

func (s *singleService) HIncrBy(
	ctx context.Context,
	req *proto.HIncrByRequest,
) (*proto.HIncrByResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HIncrBy(req.Key, req.HKeys, req.Renewal)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HIncrBy", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HIncrByResponse), nil
}

func (s *singleService) HKeys(
	ctx context.Context,
	req *proto.HKeysRequest,
) (*proto.HKeysResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HKeys(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HKeys", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HKeysResponse), nil
}

func (s *singleService) HLen(
	ctx context.Context,
	req *proto.HLenRequest,
) (*proto.HLenResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HLen(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HLen", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HLenResponse), nil
}

func (s *singleService) HSet(
	ctx context.Context,
	req *proto.HSetRequest,
) (*proto.HSetResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HSet(req.Key, req.Items)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HSet", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HSetResponse), nil
}

func (s *singleService) HSetX(
	ctx context.Context,
	req *proto.HSetXRequest,
) (*proto.HSetXResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.HSetX(req.Key, req.Items)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("HSetX", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.HSetXResponse), nil
}

func (s *singleService) CPush(
	ctx context.Context,
	req *proto.CPushRequest,
) (*proto.CPushResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.CPush(req.Key, req.Value)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("CPush", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.CPushResponse), nil
}

func (s *singleService) CPop(
	ctx context.Context,
	req *proto.CPopRequest,
) (*proto.CPopResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.CPop(req.Key, req.Count)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("CPop", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.CPopResponse), nil
}

func (s *singleService) CMake(
	ctx context.Context,
	req *proto.CMakeRequest,
) (*proto.CMakeResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.CMake(req.Key, req.Length)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("CMake", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.CMakeResponse), nil
}

func (s *singleService) CLen(
	ctx context.Context,
	req *proto.CLenRequest,
) (*proto.CLenResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.CLen(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("CLen", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.CLenResponse), nil
}

func (s *singleService) CClean(
	ctx context.Context,
	req *proto.CCleanRequest,
) (*proto.CCleanResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.CClean(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("CClean", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.CCleanResponse), nil
}

func (s *singleService) Set(
	ctx context.Context,
	req *proto.SetRequest,
) (*proto.SetResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.Set(req.Key, req.Val)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("Set", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SetResponse), nil
}

func (s *singleService) Get(
	ctx context.Context,
	req *proto.GetRequest,
) (*proto.GetResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.Get(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("Get", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.GetResponse), nil
}

func (s *singleService) Add(
	ctx context.Context,
	req *proto.AddRequest,
) (*proto.AddResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.Add(req.Key, req.Renewal)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("Add", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.AddResponse), nil
}

func (s *singleService) Reduce(
	ctx context.Context,
	req *proto.ReduceRequest,
) (*proto.ReduceResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.Reduce(req.Key, req.Renewal)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("Reduce", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.ReduceResponse), nil
}

func (s *singleService) Setnx(
	ctx context.Context,
	req *proto.SetnxRequest,
) (*proto.SetnxResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.Setnx(req.Key, req.Val)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("Setnx", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SetnxResponse), nil
}

func (s *singleService) SetBit(
	ctx context.Context,
	req *proto.SetBitRequest,
) (*proto.SetBitResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SetBit(req.Key, req.Val, req.Offer)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SetBit", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SetBitResponse), nil
}

func (s *singleService) GetBit(
	ctx context.Context,
	req *proto.GetBitRequest,
) (*proto.GetBitResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.GetBit(req.Key, req.Offer)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("GetBit", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.GetBitResponse), nil
}

func (s *singleService) GetRange(
	ctx context.Context,
	req *proto.GetRangeRequest,
) (*proto.GetRangeResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.GetRange(req.Key, req.Start, req.End)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("GetRange", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.GetRangeResponse), nil
}

func (s *singleService) GetSet(
	ctx context.Context,
	req *proto.GetSetRequest,
) (*proto.GetSetResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.GetSet(req.Key, req.Val)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("GetSet", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.GetSetResponse), nil
}

func (s *singleService) StrLen(
	ctx context.Context,
	req *proto.StrLenRequest,
) (*proto.StrLenResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.StrLen(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("StrLen", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.StrLenResponse), nil
}

func (s *singleService) SAdd(
	ctx context.Context,
	req *proto.SAddRequest,
) (*proto.SAddResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SAdd(req.Key, req.Member)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SAdd", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SAddResponse), nil
}

func (s *singleService) SCard(
	ctx context.Context,
	req *proto.SCardRequest,
) (*proto.SCardResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SCard(req.Key)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SCard", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SCardResponse), nil
}

func (s *singleService) SDiff(
	ctx context.Context,
	req *proto.SDiffRequest,
) (*proto.SDiffResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SDiff(req.Key, req.SKeys)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SDiff", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SDiffResponse), nil
}

func (s *singleService) SDiffStore(
	ctx context.Context,
	req *proto.SDiffStoreRequest,
) (*proto.SDiffStoreResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SDiffStore(req.Key, req.SKeys, req.SaveKey)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SDiffStore", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SDiffStoreResponse), nil
}

func (s *singleService) SInter(
	ctx context.Context,
	req *proto.SInterRequest,
) (*proto.SInterResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SInter(req.Key, req.SKeys)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SInter", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SInterResponse), nil
}

func (s *singleService) SInterStore(
	ctx context.Context,
	req *proto.SInterStoreRequest,
) (*proto.SInterStoreResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SInterStore(req.Key, req.SKeys, req.SaveKey)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SInterStore", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SInterStoreResponse), nil
}

func (s *singleService) SIsMember(
	ctx context.Context,
	req *proto.SIsMemberRequest,
) (*proto.SIsMemberResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SIsMember(req.Key, req.Member)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SIsMember", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SIsMemberResponse), nil
}

func (s *singleService) SMove(
	ctx context.Context,
	req *proto.SMoveRequest,
) (*proto.SMoveResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SMove(req.Key, req.MoveKey, req.Members)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SMove", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SMoveResponse), nil
}

func (s *singleService) SPop(
	ctx context.Context,
	req *proto.SPopRequest,
) (*proto.SPopResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SPop(req.Key, req.Count)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SPop", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SPopResponse), nil
}

func (s *singleService) SRem(
	ctx context.Context,
	req *proto.SRemRequest,
) (*proto.SRemResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SRem(req.Key, req.Count)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SRem", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SRemResponse), nil
}

func (s *singleService) SUnion(
	ctx context.Context,
	req *proto.SUnionRequest,
) (*proto.SUnionResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SUnion(req.Key, req.SKeys)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SUnion", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SUnionResponse), nil
}

func (s *singleService) SUnionStore(
	ctx context.Context,
	req *proto.SUnionStoreRequest,
) (*proto.SUnionStoreResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SUnionStore(req.Key, req.SKeys, req.SaveKey)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SUnionStore", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SUnionStoreResponse), nil
}

func (s *singleService) SScan(
	ctx context.Context,
	req *proto.SScanRequest,
) (*proto.SScanResponse, error) {
	work := event2.EventWorkFunc(func() (interface{}, error) {
		resp, err := s.dao.SScan(req.Key, req.Cursor, req.Regexp, req.Count)
		if err != nil {
			return nil, err
		}
		if s.aof != nil {
			s.aof.SendRequest("SScan", req)
		}
		return resp, nil
	})

	lruEvent := s.lruProduce.NewEvent(lru.OptionEventName)
	lruEvent.InitWaitEvent()
	lruEvent.SetValue(event2.WorkFuncEventKey, work)
	s.lruProduce.Call(ctx, lruEvent)
	resp, err := lruEvent.StartWaitEvent(s.timeOut)
	lruEvent.Recovery()
	if err != nil {
		return nil, err
	}

	return resp.(*proto.SScanResponse), nil
}
