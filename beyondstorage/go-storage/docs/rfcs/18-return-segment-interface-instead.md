- Author: Xuanwo <github@xuanwo.io>
- Start Date: 2020-03-23
- RFC PR: N/A
- Tracking Issue: N/A

# Proposal: Return segment interface instead

## Background

[storage] added segment support from the first release. Since then, the segment related API comes into following:

```go
type Segmenter interface {
	ListSegments(path string, pairs ...*types.Pair) (err error)
	InitSegment(path string, pairs ...*types.Pair) (id string, err error)
	WriteSegment(id string, offset, size int64, r io.Reader, pairs ...*types.Pair) (err error)
	CompleteSegment(id string, pairs ...*types.Pair) (err error)
	AbortSegment(id string, pairs ...*types.Pair) (err error)
}
```

And the data flow looks like:

```text
                                                        +----------------+
                                                        |                |
                                                 +------>    Complete    |
                                                 |      |                |
                                                 |      +----------------+
                                                 |
       +------------+         +-------------+    |
       |            |         |             |    |
       |    Init    +-------->+    Write    +----+
       |            |         |             |    |
       +------------+         +-------------+    |
                                                 |
                                                 |      +-------------+
                                                 |      |             |
                                                 +------>    Abort    |
                                                        |             |
                                                        +-------------+
```

In this implementation, we use a method called: `offset based segment`. User needs to split segment into different part via offset, and check integrity by offset and size. But most object storage services use `index based segment` via `PartNumber`, and it's hard to convert from `offset based` to `index based`, we need to make sure every part has the same size.

So we need to find a way to support both `offset based` and `index based` segment.

## Proposal

So I propose returning segment interface instead of segment id.

Instead of returning a segment ID, we should return a `segment.Segment` interface:

```go
type Segment interface {
	String() string

	ID() string
	Path() string
}
```

Developers can implement their own segment logic by them self or use the builtin index based segment.

The `Segmenter` could be changed into:

```go
type Segmenter interface {
	ListSegments(path string, pairs ...*types.Pair) (err error)
	InitSegment(path string, pairs ...*types.Pair) (seg segment.Segment, err error)
	WriteSegment(seg segment.Segment, r io.Reader, pairs ...*types.Pair) (err error)
	CompleteSegment(seg segment.Segment, pairs ...*types.Pair) (err error)
	AbortSegment(seg segment.Segment, pairs ...*types.Pair) (err error)
}
```

`segment.Segment` will be generated by services, and can't be changed outside.

## Rationale

### Index based segmenter VS Offset based segmenter

Index based segment needs `index` and `size` to mark a part, and offset based segment needs `offset` and `size`. They can't convert between without same part size. But it's hard to let user use the same part size in all write segment call.

In order to implement them both, we need to treat `size`, `offset` or `index` as a `Pair`, services can decide which one to use.

There are other implementations here:

1. `OffsetBasedSegmenter` vs `IndexBasedSegmenter`
2. `WriteSegmentViaIndex` vs `WriteSegmentViaOffset`

No.1 implementation's problem is these add too much work for services to support both of them. The problems for No.2 implementation is different segment logic needs different `init` and `abort` support, only support different `write` is not enough. And this also add too much work for implementing `Segmenter`.

### Segment interface instead of segment id

Firstly, return segment ID is a BUG. In order to distinguish a multipart upload, we need `upload_id` and `object_key`. It's possible that we have same `upload_id` for different `object_key`.

Secondly, only returning segment ID enforce us to handle the inconsistency between local and remote. 

It works for `init->write->complete`, but what happened if we tried to abort all segments? We need to `list->abort`. The `abort` func is `AbortSegment(id string, pairs ...*types.Pair) (err error)`. We have to get the corresponding path of this segment id from the local segment map, but they are empty, because they are not initiated by [storage]. In order to solve this problem, we have to update local segment map while `list`:

```go
for _, v := range output.Uploads {
    seg := segment.NewSegment(*v.Key, *v.UploadID, 0)

    if opt.HasSegmentFunc {
        opt.SegmentFunc(seg)
    }

    s.segmentLock.Lock()
    // Update client's segments.
    s.segments[seg.ID] = seg
    s.segmentLock.Unlock()
}
```

This problem can be solved via return a segment interface. After this change, user can identify a segment by them self, and local segment map is not needed any more.

## Compatibility

All segments related API has been changed.

## Implementation

Most of the work would be done by the author of this proposal.

[storage]: https://github.com/Xuanwo/storage
